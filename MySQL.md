# MySQL🐬

## 参考文档

👉  [MySQL 官方文档](https://dev.mysql.com/doc/refman/8.0/en/)

👉  [MySQL 5.1 中文文档](https://www.mysqlzh.com/)



# 逻辑架构🐬

## 连接管理与安全性



## 优化与执行

一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。

1. 通过连接器，客户端与 MySQL 建立连接
2. 分析器会通过词法分析和语法分析识别这是一条查询语句
3. 优化器会决定使用 ID 这个索引
4. 执行器负责具体执行，找到匹配的一行，然后更新

<img src="http://store.secretcamp.cn/uPic/1356806-20191024195800417-752041782202109221613281632298408V6qev5V6qev5.png" alt="1356806-20191024195800417-752041782" style="zoom: 30%;" />



# 数据类型🐬

## 整型

`TINYINT ` ：8 bit

`SMALLINT` ：16 bit

`MEDIUMINT `：24 bit

`INT`：32 bit

`BIGINT` ：64 bit



int(5) 和 int(11) 在使用的时候是没有区别的，存储范围都是 4 个字节，但是在存储时稍有区别。

例如 int(5) ，如果 id = 10，那么存储时是按照 00010 存储，会补零到 5 位，也就是不足 5 位会补零，超过 5 位则没有任何影响。



## 浮点数

`FLOAT` 和 `DOUBLE` 为浮点类型，`DECIMAL` 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 `DECIMAl` 类型的计算，因此 `DECIMAL` 的计算比浮点类型需要更高的代价。

`FLOAT`、`DOUBLE` 和 `DECIMAL` 都可以指定列宽，例如 `DECIMAL(18, 9)` 表示总共18位，取 9 位存储小数部分，剩下 9 位存储整数部分。



## 字符串

主要有 `CHAR` 和 `VARCHAR` 两种类型，一种是定长的，一种是变长的，都是声明长度表示用户想保存的最大字节数。

对于 `CHAR` ，在它们的右边填充空格以达到指定的长度，当检索到 `CHAR` 值时，尾部的空格被删除掉。

对于 `VARCHAR` ，支持的最大长度为 65535，它只保存需要的字符数，另加一或者两个字节来记录长度。

`VARCHAR` 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 `UPDATE` 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。

在进行存储和检索时，会保留 `VARCHAR` 末尾的空格，而会删除 `CHAR` 末尾的空格。



## 时间和日期

MySQL 提供了两种相似的日期时间类型：`DATETIME` 和 `TIMESTAMP`。

- `DATETIME`

  能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间，它与时区无关。

  默认情况下，MySQ L以一种可排序的、无歧义的格式显示 `DATETIME` 值，例如 "2008-01-16 22<span>:</span>37<span>:</span>08"，这是 ANSI 标准定义的日期和时间表示方法。

- `TIMESTAMP`

  和 UNIX 时间戳相同，保存从 1970年1月1日 以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。

  它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。

  MySQL 提供了 `FROM_UNIXTIME()` 函数把 UNIX 时间戳转换为日期，并提供了 `UNIX_TIMESTAMP()` 函数把日期转换为 UNIX 时间戳，默认情况下，如果插入时没有指定 `TIMESTAMP` 列的值，会将这个值设置为当前时间。

  应该尽量使用 `TIMESTAMP`，因为它比 `DATETIME` 空间效率更高。



# 存储引擎🐬

MySQL 中的数据用各种不同的技术存储在文件或内存中，这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。



## InnoDB

InnoDB 是默认的数据库存储引擎，他的主要特点有：

- 可以通过自动增长列，方法是 auto_increment。

- 支持事务。默认的事务隔离级别为可重复度，通过 MVCC（并发版本控制）来实现的。

- 使用的锁粒度为行级锁，可以支持更高的并发；

- 支持外键约束；外键约束其实降低了表的查询速度，但是增加了表之间的耦合度。

- 配合一些热备工具可以支持在线热备份；

- 在 InnoDB 中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度；

对于 InnoDB 来说，最大的特点在于支持事务。但是这是以损失效率来换取的



### 存储结构

1. `.frm` 文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等
2. `.ibd` 文件或 `.ibdata` 文件：这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。

`.ibd` 文件既是数据文件，也是索引文件。



## MyISAM

MyIASM 是 MySQL 默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当 INSERT 或 UPDATE 数据时即写操作需要锁定整个表，效率便会低一些。

MyISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。在设计之初就预想数据组织成有固定长度的记录，按顺序存储，MyISAM 是一种静态索引结构。



### 存储结构

1. `.frm ` 文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等
2. `.MYD` (`MYData`) 文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的数据
3. `.MYI` (`MYIndex`)文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的索引相关信息



## 两者的比较

|                            | MyISAM                                                       | Innodb                                                       |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 事务                       | 支持事务                                                     | 不支持事务                                                   |
| 索引                       | 非聚簇索引                                                   | 聚簇索引                                                     |
| 并发                       | 只支持表级锁，操作一条记录即锁住整张表                       | 支持行级锁                                                   |
| 外键                       | 不支持外键                                                   | 支持外键                                                     |
| 备份                       | 不支持在线热备份                                             | 支持在线热备份                                               |
| 崩溃恢复                   | 崩溃后发生损坏的概率比 InnoDB 高很多                         | 崩溃后可以恢复                                               |
| 无条件的 `select count(*)` | 快，内部维护了一个计数器存储数据量保存在磁盘上，直接读取即可 | 慢，不存储数据量，因为通过 MVCC 支持行锁，返回的数量条目是不确定的，需要全表扫描 |
| 有条件的 `select count(*)` | 慢，需要全表扫描                                             | 慢，同上需要全表扫描                                         |
| 适用场景                   | 非高并发场景：博客、文章管理等                               | 高并发的场景：电子商城                                       |







# 索引🐬

索引是帮助 MySQL 高效获取数据的排好序的数据结构。

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

对于少量的数据，没有合适的索引影响不是很大，但是，随着数据量的增加，没有索引时读数据的性能会急剧下降。而当处理的数据达到百万级或千万级时，在查询和插入的时候耗时太长、性能低下，如果将表中的数据存储到不同的分区中，将大大提高数据的能力。

- 非唯一索引（普通索引）

  非唯一索引是由关键字 `KEY` 或 `INDEX` 定义的索引，它唯一任务是加快对数据的访问速度。

  因此，应该只为那些最经常出现在查询条件或排序条件的数据列创建索引，例如年龄等。

- 唯一索引

  不允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 `UNIQUE` 把它定义为一个唯一索引。

  唯一索引可以简化 MySQL 对这个索引的管理工作，索引也因此而变得更有效率，同时在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过，如果是，MySQL 将拒绝插入那条新记录，也就是说，唯一索引可以保证数据记录的唯一性。
  
  主键索引也是唯一索引，只不过这个唯一索引被标识为主键。



## 索引的优缺点

优点 ：

- 使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）， 这也是创建索引的最主要的原因。

- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

- 帮助服务器避免进行排序和分组，以及避免创建临时表

  B+Tree 索引是有序的，可以用于 `ORDER BY` 和 `GROUP BY` 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表。

- 将随机 I/O 变为顺序 I/O，B+Tree 索引是有序的，会将相邻的数据都存储在一起。



缺点 ：

- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
- 索引需要使用物理文件存储，也会耗费一定空间。



使用条件：

- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
- 对于中到大型的表，索引就非常有效；
- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。



## 索引底层实现

### B+Tree索引

B+Tree 是大多数 MySQL 存储引擎的默认索引类型，因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。

因为 B+Tree 的有序性，所以除了用于查找，还可以用于排序和分组，可以指定多个列作为索引列，多个索引列共同组成键。

适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

<img src="http://store.secretcamp.cn/uPic/image-20210310112332239202103101123321615346612ekxKxTekxKxT.png" alt="image-20210310112332239" style="zoom:50%;" />



辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

<img src="http://store.secretcamp.cn/uPic/image-20210310112609968202103101126101615346770AoOy4oAoOy4o.png" alt="image-20210310112609968" style="zoom:50%;" />



### 哈希索引

哈希索引能以 $O(1)$ 时间进行查找，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫 “自适应哈希索引” ，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。



### 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引使用 “倒排索引” 实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。



## B+Tree索引的加载过程

如下是一个 B+Tree 索引，假设要查找数据项 6 ，那么过程如下：

1. 把根节点由磁盘块 0 加载到内存，发生一次 I/O，在内存中用二分查找确定 6 在 3 和 9 之间；
2. 通过指针 P2 的磁盘地址，将磁盘 2 加载到内存，发生第二次 I/O，再在内存中进行二分查找找到6，结束。

这里只进行了两次 I/O，实际上，每个磁盘块大小为 4kb，三层的 B+Tree 可以表示上百万的数据，也就是每次查找只需要 3 次 I/O ，所以索引对性能的提高将是巨大的。

<img src="http://store.secretcamp.cn/uPic/image-20210602223050625202106022230501622644250zOJkaxzOJkax.png" alt="image-20210602223050625" style="zoom: 40%;" />





## 聚簇与非聚簇索引

数据库表的索引从数据存储方式上可以分为聚簇索引和非聚簇索引。

在 Innodb 中主键的索引被称为聚簇索引，其他列的索引被称为辅助索引

在 MyISAM 中主键的索引被称为非聚簇索引，其他列的索引被称为辅助索引

这两种不同引擎中的辅助索引存储的结构并不相同：

- 在 Innodb 中，辅助索引叶子节点存储的是对应主键的值，通过这个值可以再进行一次聚簇索引的回表查询
- 在 MyISAM 中，辅助索引叶子节点存储的对应数据行的地址，通过这个地址可以直接找到数据，需要注意的是，MyISAM 中的非聚簇索引和辅助索引功能是完全一样的，区别仅仅只是一个作用在主键列，一个作用在其他列上。



### 聚簇索引

Innodb 使用聚簇索引（Clustered Index），“聚簇” 的意思是数据行被按照一定顺序一个个紧密地排列在一起存储。

如果表中定义了一个主键，InnoDB 将使用主键作为聚簇索引，如果没有定义，将选择第一个可以唯一标识的列作为聚簇索引列，如果也不存在这种列，InnoDB 会选择内置 6 字节长的 row_id 作为隐含的聚集索引。



#### 索引结构

InnoDB 的数据文件本身 *.ibd* 就是索引文件，数据文件本身就是按 B+Tree 组织的一个索引结构，即聚簇索引本身 “就是” 表。

聚簇索引的顺序就是数据的物理存储顺序，它会根据聚集索引键的顺序来存储表中的数据，即对表的数据按索引键的顺序进行排序，然后重新存储到磁盘上。因为数据在物理存放时只能有一种排列方式，所以一个表只能有一个聚集索引，一旦创建了聚簇索引，表中的所有列都根据构造聚簇索引的关键列来存储。

Innodb 的聚簇索引在同一个 B+Tree 中保存了索引列和具体的数据，key 为主键，实际的数据 data 保存在叶子页（Leaf Page）中，即 B+Tree 的叶节点所在的页，一个页面默认是 16KB 大小。中间的节点页保存指向下一层页面的指针。



<img src="http://store.secretcamp.cn/uPic/image-20210602224438497202106022244381622645078XM3OkHXM3OkH.png" alt="image-20210602224438497" style="zoom:50%;" />

<img src="http://store.secretcamp.cn/uPic/image-20210602224555602202106022245551622645155IDaVNRIDaVNR.png" alt="image-20210602224555602" style="zoom:50%;" />



聚簇索引性能最好而且具有唯一性，所以非常珍贵，必须慎重设置，一般默认是主键，选取的原则一般要根据这个表最常用的 SQL 查询方式来进行选择，如果已经设置了主键为聚簇索引，必须先删除主键，然后添加想要的聚簇索引，最后设置成主键即可。





#### 页分裂

页（Page）可以理解为一块具有一定大小的连续的存储区域。相同页内的数据行在物理上是相邻的，但是逻辑上键值相邻的页在物理上可能相隔很远。因此，B+Tree 相邻页中的数据，在物理上相距很远。

如果聚簇索引的列是无序的值例如 uuid ，那么新行的主键值不一定比之前插入的大，所以 InnoDB 无法简单地总是把新行插入到索引的最后，而是需要为新的行寻找合适的位置，这通常是已有数据的中间位置，就会频繁的造成页分裂，即重新组织树的数据结构，频繁的页分裂，页会变得稀疏并不被规则填充，数据会有碎片。

<img src="http://store.secretcamp.cn/uPic/image-202108182021049172021081820210516292892652Nja5v2Nja5v.png" alt="image-20210818202104917" style="zoom:50%;" />





建议使用自增列作为主键，主键的值是顺序的，所以 InnoDB 把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时，下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满。

> InnoDB 默认的最大填充因子是页大小的 15/16，留出部分空间用于以后修改

<img src="http://store.secretcamp.cn/uPic/image-202108182021511672021081820215116292893118njIYG8njIYG.png" alt="image-20210818202151167" style="zoom:50%;" />



#### 回表查询

- 若对主键进行查询，例如 `WHERE id = 11` ，按照 B+Tree 的检索算法即可查找到对应的叶节点，之后获得行数据。
- 若对其他列进行查询，比如 `WHERE name = "Ellison"` ，则需要借助辅助索引：
  - 第一步：在辅助索引 B+Tree 中检索 name ，到达其叶子节点获取对应的主键。
  - 第二步：使用主键在主索引 B+Tree 中再执行一次检索操作，最终到达叶子节点即可获取整行数据。

<img src="http://store.secretcamp.cn/uPic/image-20210310150004300202103101500041615359604yUlZnHyUlZnH.png" alt="image-20210310150004300" style="zoom: 50%;" />



#### 覆盖索引

有一种情况通过辅助索引查询但不需要回表，那就是查询的列是辅助索引中记录的，即索引包含所有需要查询的字段的值，这种情况被称为 “覆盖索引”。

```sql
# id 、name 都可以从辅助索引中获得
SELECT id, name FROM table WHERE name = "Ellison";
```



但是如果查询的列还有辅助索引无法直接提供的，那就必须要借助聚簇索引进行回表查询。

```sql
# score 无法从辅助索引中获得
SELECT id, name, score FROM table WHERE name = "Ellison";
```



#### NULL值的存储

主键索引不允许有 `NULL` 值，但是辅助索引是允许有 `NULL` 值，对于索引列值为 `NULL` 的辅助索引来说，`NULL` 值被记录在 B+Tree 的最左侧，也就是说设计者把 SQL 中的 `NULL` 值认为是列中最小的值。

因此，在查找 `NULL` 值元素时可以走索引，通过辅助索引达到 B+Tree 的最左侧，然后顺着叶子节点的指针 `next_record` 一直遍历，直到遇到一个不为 `NULL` 的元素。





### 非聚簇索引

MyISAM 使用非聚簇索引（Non- Clustered Index），其索引结构的叶子节点指向了数据对应行的物理地址。



#### 索引结构

MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。

1. *.frm* 是描述表结构文件

2. *.MYD* 是表的数据存储文件

3.  *.MYI* 是数据表的索引文件

<img src="http://store.secretcamp.cn/uPic/image-20210818200002064202108182000021629288002r3ZlD0r3ZlD0.png" alt="image-20210818200002064" style="zoom:50%;" />



在 MyISAM 的索引中，主键索引 B+Tree 的节点存储了主键，辅助键索引 B+Tree 中存储了辅助键。主索引和辅助索引在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。

<img src="http://store.secretcamp.cn/uPic/image-20210602223941285202106022239411622644781jeMPxsjeMPxs.png" alt="image-20210602223941285" style="zoom: 40%;" />

<img src="http://store.secretcamp.cn/uPic/image-20210602224141379202106022241411622644901njNaCrnjNaCr.png" alt="image-20210602224141379" style="zoom:40%;" />



这两个 B+Tree 的叶子节点都使用一个地址指向真正的表数据，由于索引树是独立的，通过辅助键检索也无需访问主键的索引树。





### 优缺点分析

聚簇索引的优点：

- 数据访问更快，因为索引和数据保存在同一个树中

- 根据局部性原理，聚簇索引的数据组织形式更易于访问相关数据。由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把整页数据加载到了内存中，再次查询的时候，可以在内存中直接访问，不必访问磁盘。
- 聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的



聚簇索引的缺点：

- 聚簇数据最大限度地提高了 I/O 密集型应用的性能，如果数据全部在内存，那么聚簇索引就没有什么优势
- 聚簇索引的插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式
- 聚簇索引的更新代价比较高，聚簇索引在插入新行和更新主键时，可能导致 “页分裂”，需要将数据移动到相应的位置。
- 聚簇索引可能导致全表扫描速度变慢，因为 B+Tree 中数据存储比较稀疏，需要加载物理上相隔较远的页到内存中。
- 聚簇索引中如果不通过主键列查找，则需要二次回表查找





两者的比较：

- 无论是聚簇索引还是非聚簇索引，在主 B+Tree 中节点发生变化，也就是发生了行移动时，辅助索引都不会受到影响。
- 聚簇索引适合用在排序的场合，非聚簇索引不适合
- 聚簇索引适合查询一定范围数据，可以将相关数据保存在一起。
- 聚簇索引维护索引的代价很昂贵，特别是插入新行或者主键被更新导致要分页时。
- 聚簇索引可能导致全表扫描速度变慢，因为可能需要加载物理上相隔较远的页到内存中（需要耗时的磁盘寻道操作）。



| **动作**           | **使用聚簇索引** | **使用非聚簇索引** |
| ------------------ | ---------------- | ------------------ |
| 列经常被分组排序   | 应该             | 应该               |
| 返回某范围内的数据 | 应该             | 不应该             |
| 一个或极少不同值   | 不应该           | 不应该             |
| 小数目的不同值     | 应该             | 不应该             |
| 大数目的不同值     | 不应该           | 应该               |
| 频繁更新的列       | 不应该           | 应该               |
| 外键列             | 应该             | 应该               |
| 主键列             | 应该             | 应该               |
| 频繁修改索引列     | 不应该           | 应该               |





## 建立索引的原则

1. 选择合适的字段创建索引：

   - 不为 NULL 的字段 ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。

   - 被频繁查询的字段 ：我们创建索引的字段应该是查询操作非常频繁的字段。

   - 被作为条件查询的字段 ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。

   - 频繁需要排序的字段 ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。

   - 被经常频繁用于连接的字段 ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

2. 被频繁更新的字段应该慎重建立索引

   虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

3. 尽可能的考虑建立联合索引而不是单列索引

   因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+Tree。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

4. 避免冗余索引

   冗余索引指的是索引的功能相同，能够命中索引 (a, b) 就肯定能命中索引 (a) ，那么索引 (a) 就是冗余索引。

   如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

5. 考虑在字符串类型的字段上使用前缀索引代替普通索引。

   前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。





## 最左前缀匹配

最左前缀匹配原则：以最左边的为起点任何连续的索引都能匹配上，遇到范围查询（>、<、between、like）就会停止匹配。

最左前缀原则主要使用在联合索引中，假如创建一个 (a,b) 的联合索引，那么它的索引树如下所示：

<img src="http://store.secretcamp.cn/uPic/image-20210327092123599202103270921231616808083BnJ52VBnJ52V.png" alt="image-20210327092123599" style="zoom: 33%;" />



可以看到 a 的值是有顺序的，1，1，2，2，3，3，而 b 的值是没有顺序的 1，2，1，4，1，2。所以 `b = 2` 这种查询条件没有办法利用索引，因为联合索引首先是按 a 排序的，b 是无序的。

同时也可以观察到，在 a 值相等的情况下，b 值又是按顺序排列的，但是这种顺序是相对的。所以 `a = 1 and b = 2` 这样的查询条件可以用到索引，但是最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引，例如 而 `a > 1 and b = 2` 中只有 a 字段可以用到索引，b 不可以，因为 a 是一个范围，在这个范围内 b 是无序的。`a = 1 and b > 2`  也可以用到，因为 a 固定则 b 是有序的。



假如建立一个联合索引 (a,b,c)

1. 全值匹配查询时

   ```sql
   select * from table_name where a = '1' and b = '2' and c = '3' 
   select * from table_name where b = '2' and a = '1' and c = '3' 
   select * from table_name where c = '3' and b = '2' and a = '1' 
   ```

   都可以用到索引，WHERE 的搜索条件顺序调换不影响查询结果，因为 MySQL 中有查询优化器，会自动优化查询顺序 



2. 匹配左边的列时

   ```java
   select * from table_name where a = '1' 
   select * from table_name where a = '1' and b = '2'  
   select * from table_name where a = '1' and b = '2' and c = '3'
   ```

   都从最左边开始连续匹配，用到了索引

   ```sql
   select * from table_name where  b = '2' 
   select * from table_name where  c = '3'
   select * from table_name where  b = '1' and c = '3'
   ```

   没有从最左边开始，最后查询没有用到索引，用的是全表扫描 
   
   ```sql
   select * from table_name where a = '1' and c = '3' 
   ```
   
   只用到了 a 列的索引，没有用到 b 和 c 的索引



3. 匹配列前缀

   如果列是字符型的话它的比较规则是先比较字符串的第一个字符，第一个字符小的哪个字符串就比较小，如果两个字符串第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小，依次类推，比较字符串。

   如果 a 是字符类型，那么前缀匹配用的是索引，后缀和中缀只能全表扫描了

   ```sql
   select * from table_name where a like 'As%';   # 前缀都是排好序的，走索引查询
   select * from table_name where a like '%As'    # 全表查询
   select * from table_name where a like '%As%'   # 全表查询
   ```



4. 匹配范围值

   ```sql
   select * from table_name where  a > 1 and a < 3
   ```

   可以对最左边的列进行范围查询

   ```sql
   select * from table_name where  a > 1 and a < 3 and b > 1;
   ```

   多个列同时进行范围查找时，只有对索引最左边的那个列进行范围查找才用到 B+Tree 索引，也就是只有 a 用到索引

   在 `1 < a < 3` 的范围内 b 是无序的，不能用索引，找到 `1 < a < 3` 的记录后，只能根据条件 `b > 1` 继续逐条过滤



5. 精确匹配某一列并范围匹配另外一列

   ```sql
   select * from table_name where a = 1 and b > 3;
   ```

   如果左边的列是精确查找的，右边的列可以进行范围查找



6. 排序

   一般情况下，我们只能把记录加载到内存中，再用一些排序算法，比如快速排序，归并排序等在内存中对这些记录进行排序，有时候查询的结果集太大不能在内存中进行排序的话，还可能暂时借助磁盘空间存放中间结果，排序操作完成后再把排好序的结果返回客户端。

   MySQL中把这种在内存中或磁盘上进行排序的方式统称为文件排序。文件排序非常慢，但如果 `ORDER BY` 子句用到了索引列，就有可能省去文件排序的步骤。

   ```sql
   select * from table_name order by a,b,c limit 10;
   ```

   因为 B+Tree 索引本身就是按照上述规则排序的，所以可以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了。

   `ORDER BY` 的子句后面的顺序也必须按照索引列的顺序给出，比如以下顺序就没有用到索引

   ```sql
   select * from table_name order by b,c,a limit 10;
   ```

   以下则用到了部分索引

   ```sql
   select * from table_name order by a limit 10;
   select * from table_name order by a,b limit 10;
   ```

   联合索引左边列为常量，后边的列排序可以用到索引

   ```sql
   select * from table_name where a =1 order by b,c limit 10;
   ```

   



# 日志系统🐬

## redo log

redo log 称为重做日志，是 Innodb 独有的，确保事务的持久性，它是物理日志，记录内容是 “在某个数据页上做了什么修改” 。InnoDB 引擎使用 redo log 保证事务的持久性，如果 MySQL 实例宕机了，重启时 InnoDB 会使用 redo log 恢复数据，保证数据的持久性与完整性。

<img src="http://store.secretcamp.cn/uPic/image-20210818203510198202108182035101629290110dcYMThdcYMTh.png" alt="image-20210818203510198" style="zoom:50%;" />



当有一条记录需要更新的时候，InnoDB 就会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 会在适当的时候，将这个操作记录更新到磁盘里面（刷脏页）。

redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么日志总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下图所示。

<img src="http://store.secretcamp.cn/uPic/image-20211002110322648202110021103221633143802Bn20HPBn20HP.png" alt="image-20211002110322648" style="zoom:20%;" />





## bin log

MySQL 从整体来看分为 Server 层和引擎层。

- Server 层：主要做的是 MySQL 功能层面的事情
- 引擎层，负责存储相关的具体事宜

redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 bin log（归档日志），bin log 属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑。

redo log 是物理日志，记录的是在某个数据页上做了什么修改；binlog 是逻辑日志，记录的是这个语句的原始逻辑，bin log 实际上类似于 Redis 的 AOF，并不能保证 crash-safe ，因为可能会丢数据。

bin log 的写入时机是 redo log 写入成功后，事务提交之前。





## undo log

undo log 称为回滚日志，保存了事务发生之前的数据的版本，可以用于回滚，基于此实现 MVCC 下的读，即快照读。





## relay log

MySQL 主节点将 bin log 写入本地，从节点定时请求增量 bin log，主节点将 binlog 同步到从节点。

从节点单独进程会将 binlog 拷贝至本地 relay log（中继日志） 中并定时重放 relay log。





## 慢查询日志

MySQL 的慢查询日志用来记录在 MySQL 中查询响应时间超过阈值的语句，具体指响应时间超过 `long_query_time` 值的 SQL，会被记录到慢查询日志，`long_query_time` 的默认值是 10s 。

慢查询日志参数：

- slow_query_log：表示是否开启慢查询日志

- slow_query_log_file：MySQL 慢查询日志存储路径，缺省值为 `host_name-slow.log`
- long_query_time：慢查询时间阈值，默认情况下为 10s

- log_queries_not_using_indexes：表示不使用索引的查询超出 long_time_query 的值也会被记录到日志中
- log_output：表示存储慢查询日志方式



# 主从复制🐬

主从同步指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。对于多级复制，数据库服务器即可充当主机，也可充当从机。

生产环境中，数据库大多都是读操作，所以部署一主多从架构，主数据库负责写操作，并做双击热备，多台从数据库做负载均衡，负责读操作，并通过数据复制机制，在主节点和只读节点之间进行数据的实时同步，保证主从节点的数据一致性。



## 主从复制的优点

1. 实现服务器的负载均衡

   即可以通过在主服务器和从服务器之间切分处理客户查询的负荷，从而得到更好的客户相应时间，一般有两种思路：

   - 主服务器上只实现数据的更新操作。

     包括数据记录的更新、删除、新建等等作业。而不关心数据的查询作业。数据库管理员将数据的查询请求全部转发到从服务器中。这在某些应用中会比较有用。

   - 主服务器上与从服务器切分查询的作业。

     在这种思路下，主服务器不单单要完成数据的更新、删除、插入等作业，同时也需要负担一部分查询作业。而从服务器的话，只负责数据的查询。当主服务器比较忙时，部分查询请求会自动发送到从服务器重，以降低主服务器的工作负荷。



2. 通过复制实现数据的异地备份

   可以定期的将数据从主服务器上复制到从服务器上，实现了数据的异地备份。

   在传统的备份体制下，是将数据备份在本地。此时备份作业与数据库服务器运行在同一台设备上，当备份作业运行时就会影响到服务器的正常运行。有时候会明显的降低服务器的性能。同时，将备份数据存放在本地，也不是很安全。如硬盘因为电压等原因被损坏或者服务器被失窃，此时由于备份文件仍然存放在硬盘上，数据库管理员无法使用备份文件来恢复数据。



3. 故障时取代主服务器

   当主服务器出现问题时，数据库管理员可以马上让从服务器作为主服务器，用来数据的更新与查询服务。

   双击热备：应用于服务器的一种解决方案，其构造思想是主机和从机通过 TCP/IP 网络连接，正常情况下主机处于工作状态，从机处于监视状态，一旦从机发现主机异常，从机将会在很短的时间之内代替主机，完全实现主机的功能。

   - 部分取代主服务器

     主服务器故障之后，从服务器取代了主服务器的位置，但是对其可以采取的操作做了一些限制。

     如只能够进行数据的查询，而不能够进行数据的更新、删除等操作。这主要是从数据的安全性考虑。例如银行系统在升级的过程中，只能够查询余额而不能够取钱就是这个原因。

   - 完全取代主服务器

     当从服务器切换为主服务器之后，其地位完全与原先的主服务器相同。此时可以实现对数据的查询、更新、删除等操作。



## 主从复制原理

MySQL 主从复制的基础是主服务器对数据库修改记录二进制日志（Binary Log），从服务器通过主服务器的二进制日志自动执行更新。

一句话表示就是，主数据库做什么，从数据库就跟着做什么。

- 基于语句的复制 ：主库把 SQL 语句写入到 Binary Log 中，完成复制
- 基于行数据的复制：主库把每一行数据变化的信息作为事件，写入到 Binary Log，完成复制
- 混合复制：上面两个结合体，默认用语句复制，出问题时候自动切换成行数据复制



和上面相对应的日志格式也有三种: STATEMENT 、ROW 、MIXED

- STATEMENT

  每一条修改数据的 SQL 语句会记录到 Binary Log 中。优点是并不需要记录每一条 SQL 语句和每一行的数据变化，减少了 binlog 日志量，节约 I/O ，提高性能。缺点是在某些情况下会导致 Master-Slave 中的数据不一致

  > 如 sleep()、last_insert_id()、user-defined functions(udf) 等会出现问题

- ROW

  不记录每条 SQL 语句的上下文信息，仅需记录哪条数据被修改了，修改成什么样了。而且不会出现某些特定情况下的存储过程、或 function、或 trigger 的调用和触发无法被正确复制的问题，缺点是会产生大量的日志，尤其是修改表结构的时候会让日志暴涨。

- MIXED

  以上两种模式的混合使用，一般的复制使用 STATEMENT 模式保存 Binary Log ，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 Binary Log ，MySQL 会根据执行的 SQL 语句选择日志保存方式。



工作流程：

1. Master 数据库只要发生变化，立刻记录到 Binary Log 日志文件中

2. Slave 数据库启动一个 I/O Thread 连接 Master 数据库，请求 Master 变化的二进制日志

3. Slave I/O 获取到二进制日志，保存到自己的 Relay log 日志文件中

4. Slave 有一个 SQL thread 定时检查 Relay log 是否变化，如果变化就更新数据

<img src="http://store.secretcamp.cn/uPic/image-202109012038582522021090120385816304999382ZgKdc2ZgKdc.png" alt="image-20210901203858252" style="zoom:40%;" />

## 主从复制延迟

MySQL 数据库主从同步可能存在延迟。

MySQL 的主从复制都是单线程的操作，主库对所有 DDL 和 DML 产生的日志写进 bin log ，由于 bin log 是顺序写，所以效率很高。但是 Slave 的 SQL Thread 线程也是单线程的，当主库的并发较高时，产生的同步 SQL 数量超过 Slave 的 SQL Thread 所能处理的速度，那么主从复制延时就产生了。

`show slave status` 可以查看主从复制延迟情况，主要是根据 `Seconds_Behind_Master` 字段，值越高则主从延迟越大。

主从延迟的解决方法：

1. 半同步复制

   介于异步复制和同步复制之间，Master 在执行完事务后不立刻返回结果给客户端，需要等待至少一个 Slave 接收到并写到 relay log 中才返回结果给客户端。

2. 降低从库安全性要求

   从库配置sync_binlog = 0，该参数表示是否将 binlog 刷到磁盘

   从库配置 innodb_flush_log_at_trx_commit =0，该参数表示每 N 次事务提交或事务外的指令都需要把日志刷到磁盘

3. 增加 Slave 的数量，降低单台 Slave 上的读压力

4. 提高 Slave 的配置



如果出现了主从延迟，又无法解决，MySQL 的处理方法是：

1. 强制将读请求路由到主库处理。

2. 延迟读取



# 分库分表分区🐬

## 分表

数据量的日剧增加，数据库中某个表有几百万条数据，导致查询和插入耗时太长，可以把单个表拆分成多个表，来减轻单个表的压力，提高处理效率。

- 垂直拆分：把原来的一个很多字段的表拆分多个表，解决表的宽度问题。可以把不常用的字段单独放到一个表中，也可以把大字段独立放一个表中，或者把关联密切的字段放一个表中。

- 水平拆分（更普遍）：把原来一个表拆分成多个表，每个表的结构都一样，解决单表数据量大的问题。

<img src="http://store.secretcamp.cn/uPic/image-20210828111944042202108281119441630120784XWwlw1XWwlw1.png" alt="image-20210828111944042" style="zoom:35%;" />





## 分库

分库就是将数据库中的数据分散到不同的数据库上。

例如：

- 将数据库中的用户表和用户订单表分别放在两个不同的数据库。
- 由于用户表数据量太大，对用户表进行水平切分，然后将切分后的 2 张用户表分别放在两个不同的数据库。



## 分区

分区：将一张表的数据根据表结构中的字段（range、list、hash等）分成多个区块，这些区块可以在一个磁盘上，也可以在不同的磁盘上，分区后，表面上还是一张表，但数据散列在多个位置，这样一来，多块硬盘同时处理不同的请求，从而提高磁盘 I/O 读写性能。

优点：

- 实现简单，多数存储服务都自带分区实现。
- 对应用开发者透明，只是建表时需要确定分区方案。
- 分区将大数据切分到不同的数据节点，提升了访问性能。



MySQL 的分区策略主要有以下几种：

1. Hash 分区
2. Range 分区
3. Key 分区
4. List 分区
5. Columns 分区





## 分库分表的场景

遇到下面几种场景可以考虑分库分表：

- 单表的数据达到千万级别以上，数据库读写速度比较缓慢（分表）。
- 数据库中的数据占用的空间越来越大，备份时间越来越长（分库）。
- 应用的并发量太大（分库）。



## 分库分表的优缺点

分库分表之后带来的问题：

分库之后， 同一个数据库中的表分布在了不同的数据库中

- join 操作 ：无法使用 join 操作。这样就导致需要手动封装数据。
- 事务问题 ：如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足要求，必须使用分布式事务。
- 分布式 id ：数据库的自增主键已经没办法满足生成的主键唯一了，必须引入分布式 id 。



## 分库后的数据迁移

分库分表之后，需要将老库的数据迁移到新库。

1. 停机迁移：写个脚本将老库的数据写到新库中
2. 双写迁移：
   - 对老库的增删改操作，同时也要写入新库。如果操作的数据不存在于新库的话，需要插入到新库中。 这样就能保证，新库里的数据是最新的。
   - 另外写脚本将老库中的数据迁移到新库



# EXPLAIN🐬

## explain分析

Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。



### SELECT_TYPE

- SIMPLE：简单查询，不使用 UNION 或子查询等

- PRIMARY：子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)

- UNION(UNION中的第二个或后面的SELECT语句)

- DEPENDENT UNION(UNION中的第二个或后面的 SELECT 语句，取决于外面的查询)

- UNION RESULT(UNION的结果，union语句中第二个 SELECT 开始后面所有 SELECT )

- SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)

- DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)

- DERIVED(派生表的SELECT, FROM子句的子查询)

- UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)





### TYPE

常用的类型有： ALL、index、range、 ref、eq_ref、const、system、NULL

从左到右，性能从差到好

- ALL： MySQL 将遍历全表以找到匹配的行

- index：只遍历索引树

- range：只检索给定范围的行，使用一个索引来选择行

- ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

- eq_ref：类似 ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用 primary key 或者 unique key 作为关联条件

- const、system：当 MySQL 对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量，system 是 const 类型的特例，当查询的表只有一行的情况下，使用 system

- NULL：MySQL 在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。



### possible_keys

显示可能应用在表中的索引，可能一个或多个，但不一定被查询实际使用。



### key

实际中使用的索引名称，如果没有用到索引则为 NULL 。

possible_keys 表示理论上可能用到的索引，key 表示实际中使用的索引。



### keylen

表示索引中所使用的字节数，可通过该列计算查询中使用的索引长度



### ref

显示关联的字段，如果使用常数等值查询，则显示const，如果是连接查询，则会显示关联的字段。



### rows

 估算出结果集行数，表示 MySQL 根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数。



### filtered

百分比值，表示存储引擎返回的数据经过滤后，剩下多少满足查询条件记录数量的比例。



### extra

显示十分重要的额外信息。

- `Using where`：优化器需要通过索引回表查询数据

- `Using index`：表明相应的查询操作中使用了覆盖索引，效率不错。

  如果同时出现了 `Using where`，表明索引被用来执行索引键值的查找，即包含了 WHERE 语句。

  如果没有同时出现 `Using where`，表明索引用来读取数据而非执行查找动作。

- `Using temporary`：使用临时表来存储中间结果，常见于排序和分组查询，这种情况说明当前 SQL 应该被优化。

- `Using filesort`：当查询中包含 ORDER BY 操作，而且无法利用索引完成的排序操作称为 “文件排序”，这种情况说明当前 SQL 应该被优化。



## 查询优化器

查询优化器（Optimizer）的任务是发现执行 SQL 查询的最佳方案。

- 逻辑优化：主要功能是基于关系代数以及启发式规则，找出SQL语句等价的变换形式，使得SQL执行更高效；

- 物理优化：即根据代价估算模型，选择最优的表连接顺序以及数据访问方式，这个阶段依赖于对数据的了解。





# MySQL调优🐬

## 基本设计规范

1. 所有表必须使用 Innodb 引擎

   Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。

2. 尽量控制单表数据量的大小，建议控制在 500 万以内

3. 谨慎使用 MySQL 分区表

   分区表在物理上表现为多个文件，在逻辑上表现为一个表，因为跨分区查询效率可能更低，建议采用物理分表的方式管理大数据。

4. 禁止在数据库中存储图片，文件等大的二进制数据





## 数据类型优化

1. 选择合适的数据类型的长度

   如果字段的长度很大，那么读取数据也需要更多的 I/O，所以合理的字段长度也能提升数据库的性能。

2. 尽可能把所有列定义为 NOT NULL
3. 使用 `TIMESTAMP` 或 `DATETIME` 类型存储时间
4. 财务相关的金额类数据必须使用 `decimal` 类型



## 索引优化（避免索引失效）

1. 不要用 `like "%xxxx"` 后缀查询，会导致索引失效，但前缀查询  `like "xxxx%"`  可以用到索引

2. 少用 `or`，用它来连接时会导致索引失效

3. `<，<=，=，>，>=，BETWEEN，IN` 可用到索引，`<>，not in ，!=` 则不行，会导致全表扫描

4. 索引应建立在那些将用于 `JOIN` 、`WHERE` 、`ORDERBY` 排序的字段上，这样可以避免 FileSort
5. 对于频繁的查询优先考虑使用覆盖索引





## 查询优化

1. 使用预编译语句进行数据库操作

   只传参数，比传递 SQL 语句更高效，通过动态 SQL 解决 SQL 注入的问题

2. 避免使用子查询，可以把子查询优化为 join 操作

3. 避免使用 JOIN 关联太多的表

4. 超 100 万行数据的批量写操作，要分批多次进行操作

   大批量操作一般都需要执行一定长的时间，可能会造成严重的主从延迟
   
5. 禁止不带任何限制数据范围条件的查询语句，例如用户在查询订单历史控制在一个月的范围内

6. 小表驱动大表：小表的数据量少，相当于用少的连接次数中做了更多的操作



## 慢查询优化

常见的慢查询原因：

1. 没有索引或者没有用到索引
2. SQL 语句过于复杂
3. 加锁或者死锁

4. 内存不足
5. 表的数据量太大



解决方法：

1. 合理使用索引，避免索引失效
2. 分解关联查询，将大的查询分解为多个小查询，少用 `LEFT JOIN` 和 `RIGHT JOIN` ，因为表之间的连接的顺序被固定了，左连接就是必须先查左表全表扫描，然后一条一条的到另外表去查询。但是 `INNER JOIN` 是可以用到索引的。
3. 检查事务的合理性
4. 升级硬件
5. 考虑分库分表



# FAQ🐬

## 为什么不宜使用过长的字段作为主键？

因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。



## 为什么不宜使用uuid之类的字段作为主键？

InnoDB 数据文件本身是 B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

uuid 不具有有序性，所以在写的时候要对节点进行插入操作，需要读取整个 B+Tree 节点到内存，写的过程中会造成页分裂，插入节点后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。另外，由于频繁页分裂造成 B+Tree 中页变得稀疏并不被规则填充，索引查询时会按页记载，因此  I/O 的次数也会增多。

在下图的测试中，使用 uuid 作为聚簇索引，无论是时间还是索引大小，都比自增 id 效率差的多。

<img src="http://store.secretcamp.cn/uPic/image-202108182018038882021081820180416292890849RMtix9RMtix.png" alt="image-20210818201803888" style="zoom:50%;" />



## 顺序主键在什么场景下会产生不好的结果？

- 单主数据库架构，那么自增 id 是不会重复，但在高并发场景下，按主键顺序插入可能造成明显的争用，这里会成为系统的瓶颈，而且也容易成为一个单点故障。

- 主从架构，可以解决单点故障的问题，但不会解决生成 id 瓶颈的问题。在主数据库挂掉，进行主从切换的时候，这个自增 id 可能出现重复，所以需要使用分布式唯一主键生成方案。





## 非聚集索引一定回表查询吗？

如果命中了覆盖索引则不必回表。

非聚簇索引叶子节点中保存的是数据的指针，一般还需要一次 I/O 才能查到数据，但如果 id 字段有索引且查的就是 id，则命中覆盖索引，直接返回数据。

```sql
SELECT id FROM table WHERE id=1;
```



## 如何删除百万量级的数据

由于索引需要额外的维护成本，对于非聚簇索引，因为索引文件是单独存在的文件，所以当我们对数据的增加、修改、删除，都会产生额外的对索引文件的操作，这些操作需要消耗额外的 I/O，会降低 CRUD 的执行效率。

删除数据的速度和创建的索引数量是成正比的，所以想要删除百万数据的时候可以先删除索引。

1. 删除索引
2. 删除数据
3. 重建索引

