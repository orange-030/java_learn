# HTTP🎃 

HTTP 属于 OSI 网络七层协议模型中的应用层，由请求和响应构成，是一个标准的客户端服务器模型。

HTTP是一个无状态的协议，默认端口号为80。

无状态是指一种把每个请求作为与之前任何请求都无关的独立的事务的



## URL

客户端（Client）：发送请求获取服务器资源的一端

服务端（Server）：提供资源响应的一端

URI（Uniform Resource Identify ）：统一资源标识符

URL（Uniform Resource Locator）：统一资源定位符

URI 用字符串标识某一互联网资源，而URL表示资源的地点（即在互联网上所处的位置）。URL是URI的子集。

```
protocol://host [:port]/path/[?query1&query2]#fragment
http://www.itcast.cn/index.html?name=andy&age=18#link
```

| 组成     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| protocol | 通信协议常用的http，ftp，maito等                             |
| host     | 主机（域名）www.itheima.com                                  |
| port     | 端口号可选，省略时使用方案的默认端口如http的默认端口为80     |
| path     | 路径由零或多个`/`符号隔开的字符串，一般用来表示主机上的一个目录或文件地址 |
| query    | 参数以键值对的形式，通过`&`符号分隔开来                      |
| fragment | 片段 #后面内容常见于链接锚点                                 |



## HTTP版本

目前主流的 HTTP/1.1 自 1999 年发布后没有再经过修订，已经逐渐无法适应当下的 Web 环境



### HTTP/1.0

只有 GET、POST、HEAD 方法

规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。




### HTTP/1.1

1. 引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用。
2. 引入了管道机制（pipelining），即在同一个 TCP 连接里面，客户端可以同时发送多个请求。



### Ajax

Ajax（Asynchronous JavaScript and XML，异步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文档对象模型）的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见。

然而，利用 Ajax 实时从服务器获取内容，有可能会导致大量请求产生，因此，Ajax 仍未解决 HTTP 协议本身存在的问题。



### SPDY

SPDY  的目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间

1. 降低延迟

   针对 HTTP 高延迟的问题，SPDY 优雅的采取了多路复用（multiplexing）。多路复用通过多个请求流共享一个 TCP 连接的方式，解决了HOL blocking 的问题，降低了延迟同时提高了带宽的利用率。

2. 请求优先级

   多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个 request 设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的 html 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。

3. header 压缩

   前面提到 HTTP/1.x 的 header 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。

4. 基于 HTTPS 的加密协议传输

   大大提高了传输数据的可靠性。

5. 服务端推送（Server Push）

   采用了 SPDY 的网页，例如网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。



### WebSocket

WebSocket 是 Web 浏览器与 Web 服务器之间全双工通信标准。

一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接， 之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式的数据。由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端， 而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。



优点：

1. 推送功能：支持由服务器向客户端推送数据的推送功能。
2. 减少通信量：只要建立起 WebSocket 连接，就一直保持连接状态。
3. header 压缩：WebSocket 的首部信息 很小，通信量也相应减少了。



### HTTP/2.0 

HTTP/2.0 建立在 SPDY 和 WebSocket 基础之上，目标是改善用户在使用 Web 时的速度体验。

HTTP/2.0 和 HTTP/1.X 相比的新特性：

- 新的二进制格式（Binary Format）

  HTTP/1.X 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。

- 多路复用（MultiPlexing）

  即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。

- header 压缩

  如上文中所言，对前面提到过 HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。

- 服务端推送（server push）

  同 SPDY 一样，HTTP2.0 也具有 server push 功能。



## HTTP方法

### GET

GET 方法用来请求已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。

如果请求的资源是文本，那就保持原样返回；如果是像 CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。



### POST

POST方法用来传输实体的主体。

虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但POST 的主要目的并不是获取响应的主体内容。



### HEAD

HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。



### PUT

PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。



### DELETE

DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。



### OPTIONS

OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。





# HTTP报文🎃 

## HTTP报文结构

用于 HTTP 协议交互的信息被称为 HTTP 报文。客户端的 HTTP 报文叫做请求报文，服务器端的叫做响应报文。HTTP 报文本身是由多行数据构成的字符串文本。

报文结构：` 报文首部 + 空行(CR+LF) + 报文主体`

<img src="http://store.secretcamp.cn/uPic/HTTP01202103012046201614602780Q0KhByQ0KhBy.png" style="zoom:67%;" />



请求行：包含用于请求的方法，请求 URI 和 HTTP 版本

```
GET /index.html HTTP/1.1
```

状态行：包含表明响应结果的状态码，原因短语和HTTP版本

```
HTTP/1.1 200 OK
```

![](http://store.secretcamp.cn/uPic/HTTP02202103012109131614604153etWpLCetWpLC.png)











## HTTP首部

HTTP 报文分为请求报文和响应报文

| HTTP请求报文首部              | HTTP响应报文首部           |
| ----------------------------- | -------------------------- |
| 请求行（方法，URL，HTTP版本） | 状态行（HTTP版本，状态码） |
| 请求首部字段                  | 响应首部字段               |
| 通用首部字段                  | 通用首部字段               |
| 实体首部字段                  | 实体首部字段               |



### 通用首部字段

| 协议头        | 说明                                      | 举例                                                         |
| ------------- | ----------------------------------------- | ------------------------------------------------------------ |
| Connection    | 客户端（浏览器）想要优先使用的连接类型    | Connection: keep-alive (Upgrade)                             |
| Date          | 报文创建时间                              | Date: Dec, 26 Dec 2015 17: 30: 00 GMT                        |
| Cache-Control | 用来指定当前的请求/回复中是否使用缓存机制 | Cache-Control: no-store                                      |
| Via           | 告诉服务器，这个请求是由哪些代理发出的    | Via: 1.0 fred, 1.1 [itbilu.com.com](http://itbilu.com.com/) (Apache/1.1) |



### 请求首部字段

| 协议头          | 说明                                     | 举例                                               |
| --------------- | ---------------------------------------- | -------------------------------------------------- |
| Accept          | 告诉服务器自己允许哪些媒体类型           | Accept: text/plain                                 |
| Accept-Charset  | 浏览器申明可接受的字符集                 | Accept-Charset: utf-8                              |
| Accept-Encoding | 浏览器申明自己接收的编码方法             | Accept-Encoding: gzip, deflate                     |
| Authorization   | 用于表示HTTP协议中需要认证资源的认证信息 | Authorization: Basic OSdjJGRpbjpvcGVul ANIc2SdDE== |
| User-Agent      | 浏览器的身份标识字符串                   | User-Agent: Mozilla/……                             |
| Host            | 表示服务器的域名以及服务器所监听的端口号 | Host: www.itbilu.com:80                            |



### 响应首部字段

| 协议头      | 说明                       | 举例                                         |
| ----------- | -------------------------- | -------------------------------------------- |
| Age         | 创建响应的时间             | Age：5744337                                 |
| Server      | 告知客户端服务器信息       | Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) |
| Retry-After | 告知客户端多久后再发送请求 | Retry-After: 120                             |
| Location    | 表示重定向后的 URL         | Location:https://www.baidu.com               |



### 实体首部字段

| 协议头           | 说明                                          | 举例                                   |
| ---------------- | --------------------------------------------- | -------------------------------------- |
| Allow            | 对某网络资源的有效的请求行为，不允许则返回405 | Allow: GET, HEAD                       |
| Content-encoding | 返回内容的编码方式                            | Content-Encoding: gzip                 |
| Content-Length   | 返回内容的字节长度                            | Content-Length: 348                    |
| Content-Type     | 返回内容的 MIME 类型                          | Content-Type: text/html; charset=utf-8 |
| Expires          | 响应过期的日期和时间                          | Expires: Thu, 01 Dec 2010 16:00:00 GMT |



### 其他首部字段

| 协议头          | 说明                                               | 举例                                    |
| --------------- | -------------------------------------------------- | --------------------------------------- |
| Set-Cookie      | 在用户状态管理中使用的cookie信息（响应首部）       |                                         |
| Cookie          | 服务器接收到的cookie信息（请求首部）               |                                         |
| X-Frame-Options | 用于控制网站内容在其他Web网站的Frame标签的显示问题 | X-Frame-Options: <br>DENY \| SAMEORIGIN |
| DNT             | 表示Do Not Trace                                   | DNT:1                                   |



## 状态码

### 1XX

信息，服务器收到请求，需要请求者继续执行操作

### 2XX

成功，操作被成功接收并处理

- 200：OK，请求成功

- 201：CREATED-[POST/PUT/PATCH]，用户新建或修改数据成功

- 202：Accepted-[]：表示一个请求已经进入后台排队（异步任务）

- 204：NO CONTENT-[DELETE]，表示数据删除成功



### 3XX

- 301：Moved Permanently，永久性重定向
- 302：Found，临时性重定向，需要进一步的操作以完成请求
- 303：See Other，表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。
- 304：Not Modified：表示用户查找的资源存在，但是不满足请求需要的条件。
- 307：Temporary Redirect，临时重定向，和 302 相同



### 4XX

客户端错误，请求包含语法错误或无法完成请求

- 400：Bad Request，客户端请求的语法错误，服务器无法理解
- 401：Unauthorized，表示用户没有权限（令牌，用户名，密码错误）
- 403：Forbidden，服务器理解请求客户端的请求，但是拒绝执行此请求
- 404：Not Found，服务器无法根据客户端的请求找到资源
- 405：Method Not Allowed，客户端请求中的方法被禁止
- 406：Not Acceptable，用户请求格式不可得

- 410：Gone，用户请求的资源被永久移除，且不会再得到的



### 5XX

服务器错误，服务器在处理请求的过程中发生了错误

- 500：Internal Server Error，服务器内部错误，无法完成请求

- 503：Service Unavailable，服务器暂时处于超负载或正在进行停机维护





# Cookie和Session🎃 

HTTP 是一种无状态协议，即 HTTP 协议自身不对请求和响应之间的通信状态进行保存，使用 HTTP 协议时，每当有新的请求发送时，都会有对应的新响应产生，这是为了能够快速的处理大量事务。随着 Web 发展，许多网站都希望能够保持用户的状态，于是引入了会话技术。

会话（Session）跟踪是 Web 程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是 Cookie 与 Session 。

- Cookie：通过在客户端记录信息确定用户身份

- Session：通过在服务器端记录信息确定用户身份

一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。由于 HTTP 协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。



## Cookie

Cookie 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie。客户端浏览器会把 Cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。服务器还可以根据需要修改 Cookie 的内容。

当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。

- 优点：服务器不用保存状态信息，减轻服务器存储压力，同时便于服务端做水平拓展。

- 缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。







## Session

Session是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 Session 保存在服务器上。

在客户端第一次向服务器发送HTTP请求后，服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来，然后分配一个会话标识（ SessionId ）给客户端，这个会话标识一般保存在客户端 Cookie 中，之后每次该浏览器发送 HTTP 请求都会带上 Cookie 中的 SessionId 到服务器，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。

- 优点：
  1. 安全性高，因为状态信息保存在服务器端
  2. 相比 JWT，最大优势是可以主动清除 Session
- 缺点：
  1. 服务器存储压力大
  2. 集群环境下需要做多机共享session机制。由于大型网站往往采用的是分布式服务器，浏览器发送的 HTTP 请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，单纯基于 Session 的方法就不能实现会话保持了，此时可以考虑 Sticky Session 、Session Replication 等方法。



session 可以通过 cookie 存储一个变量 `sessionID=xxxx`，仅仅把这一个 cookie 传给服务器，然后服务器通过这个 ID 找到对应的 session 。

由于 session 存储在服务器中，肯定会消耗服务器的资源，所以 session 一般都会有一个过期时间，服务器一般会定期检查并删除过期的 session，如果后来该用户再次访问服务器，可能就会面临重新登录等等措施，然后服务器新建一个 session，将 session ID 通过 cookie 的形式传送给客户端。





# HTTPS🎃

HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。

HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容，与 SSL 组合使用的 HTTP 被称为 HTTPS 。

HTTPS 是 HTTP 直接将报文信息传输给 SSL 套接字进行加密，SSL 加密后将加密后的报文发送给 TCP 套接字，然后 TCP 套接字再将加密后的报文发送给目的主机，目的主机将通过 TCP 套接字获取加密后的报文给SSL套接字，SSL 解密后交给对应进程。



## HTTP的缺陷

传统的 HTTP 协议通信：直接将报文信息传输到 TCP，然后 TCP 再通过 TCP 套接字发送给目的主机上。

- 通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，任何人都可以发送请求，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能已遭篡改



## 加密方式

HTTPS 采用了混合加密方式，在密钥交换环节现在用非对称加密让客户端将密钥发送给服务端，之后采用对称加密进行通信。



### 对称加密

加密和解密同用一个密钥的方式称为对称加密（共享密钥加密）。客户端根据密钥对数据就行加密，服务端根据密钥对数据进行解密，所以加密和解密都需要密钥。

对称加密算法：DES、AES

❗ 存在的问题：共享密钥加密的前提是将密钥成功发送给对方，然而在发送密钥的过程中通信可能会遭到监听，那么密钥就会遭到泄漏。



### 非对称加密

非对称加密（公开密钥加密）使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。

事实上，公钥与私钥就是两组具有某种函数关系的数字串，可以相互之间加密解密。

使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。

非对称加密算法：RSA

RSA 是一种公钥密码体制，现在使用非常广泛，这个密码体制分为三部分：公钥、私钥、加密算法，其中公钥和加密算法是公开的，私钥是自己保密的。这种机制最大的特点是，通过公钥加密的密文只有对应的私钥才能解密，同样通过私钥加密的密文也只有对应的公钥才能解密。

❗  存在的问题：无法证明公开密钥本身是货真价实的，因为在公开密钥的传输过程中，真正的公开密钥可能会被替换。



## 数字证书

数字证书是 HTTPS 实现安全传输的基础，它是由权威的数字证书认证（CA）机构颁发的。

由于公开密钥加密自身存在的问题：即无法证明服务端的公开密钥是货真价实的。为了解决这个问题，数字证书认证机构（CA）颁发了公开密钥证书来证明服务器公钥的真实性。

1. 服务端相关人员向数 CA 发出申请
2. CA 验证申请者的身份，对申请的公开密钥做数字签名，并将公开密钥和公钥证书绑定
3. 服务端将 CA 颁布的公钥证书发送给客户端
4. 客户端使用证书中的公开密钥对向 CA 认证数字签名，验证成功则说明公钥真实



证书的主要内容有：

- 公钥

- 证书的发布机构

- 证书持有者

- 证书有效期

- 指纹及指纹算法（需要解密签名）

  指纹用来保证证书的完整性的，确保证书没有被篡改。证书在发布之前，CA 对证书的内容用指纹算法（sha1或sha256）计算得到一个 hash 值，这个 hash 值就是指纹。

- 签名

  签名是在信息后面加上的一段数字串，可以证明该信息有没有被篡改。数字证书发布的时，CA 将证书的指纹和指纹算法通过自己的私钥加密，得到的就是证书的签名。



### 根证书

CA 除了给别人颁发证书以外，它也有自己的证书，这个证书是机构自己颁发给自己的，它被称为根证书。根证书的私钥是 CA 绝对保密的，在验证其他证书的过程中起着核心的作用。

世界上权威 CA 机构的根证书都是预先嵌入到浏览器中的，HTTPS 过程中如果在浏览器系中没有找到对应的根证书，就代表此机构不是受信任的，那么就会警告无法确认证书的真假。



### 证书的验证过程

根私钥加密 [ hash (证书内容), hash 算法] = 证书签名

1. 在 HTTPS 中，服务端接收到请求后，就会给客户端发送一个自己的 CA 数字证书。

2. 如果找到了证书颁发机构的根证书，那么就从根证书中取得那个根公钥，用根公钥去解密此证书的数字签名，成功解密的话就得到证书的指纹 h1 和指纹算法，h1 是未被篡改过的证书的指纹。

   > 可以保证根公钥一定是没有被篡改的

3. 用指纹算法对当前接收到的证书内容再进行一次 hash 计算得到另一个值 h2，如果此时 h1 和 h2 是相等的，就代表证书没有被篡改过，验证通过。如果证书被篡改过，h1 和 h2 是不可能相等的，验证不通过。



证书被篡改的可能性：

由于 RSA 算法的非对称性，即使攻击者伪造了证书，拿自己的私钥加密，用户拿的是 CA 的公钥解密，验证不可能通过，攻击者拿 CA  的公钥加密，用户拿 CA 公钥解密，验证也不可能通过，这里只有拿 CA 的私钥才能解密。所以 CA 的私钥应该足够复杂，不然可能会被暴力破解。



## HTTPS的安全通信过程

1. 客户端在浏览器里输入一个 HTTPS 网址，然后连接到服务端的 443 端口，向服务端发送 Client Hello 报文，以明文传输请求信息，发送的信息主要包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息。
2. 服务端返回协商的信息结果，包括选择使用的协议版本、选择的加密套件、选择的压缩算法、随机数以及数字证书。数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。
3. 客户端验证证书的合法性，包括是否可信，是否吊销，过期时间等（通过根证书）。
4. 客户端确认证书的有效性后，生成一串随机数（即对称加密的密钥），用服务端证书中的公钥对该随机数进行加密，然后发送给服务端。这一步目的是为了让服务端得到这个随机值。
5. 客户端向服务端发送 Finish 报文，通知服务端之后的通信采用对称加密。
6. 服务器接收到加密的随机数后，用私钥对其进行解密后得到随机数，该随机数即对称加密的密钥。服务器向客户端发送报文，同意采用对称加密进行通信。
7. 服务器向客户端发送 Finish 报文
8. 客户端与服务端的 Finish 报文交换完成后，SSL 连接建立完成，开始进行 HTTP 通信。



<img src="http://store.secretcamp.cn/uPic/HTTPS_1202103012131491614605509kDsn0xkDsn0x.png" style="zoom:80%;" />







## HTTPS的缺点

HTTPS 比 HTTP 要慢 2~100 倍，因为 HTTPS 还需要做服务器、客户端双方加密及解密处理，因此会消耗 CPU 和内存等硬件资源。和 HTTP 通信相比，SSL 通信部分消耗网络资源，同时又因为要对通信进行处理，所以时间上又延长了，所以 SSL 的慢主要是指通信慢和大量消耗 CPU 及内存资源。



 

## HTTP和HTTPS比较

- HTTP 协议以明文方式发送内容，数据都是未加密的，安全性差；HTTPS 数据传输过程是加密的，安全性好。

- HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。

- HTTPS 协议需要到数字认证机构（CA）申请证书，一般需要一定的费用。

- HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 TCP 的 3 次握手建立连接，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。







# RESTful API🎃

一种软件架构风格、设计风格、而不是标准，只是提供了一组设计原则和约束条件。它主要用于户客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。

REST 全称是 Representational State Transfer，REST 的释义是指 “表现层状态转化”，其实这省略了主语。“表现层"其实指的是“资源（Resource）”的表现层，所以面向资源是 REST 最显著的特征，符合 REST 的设计风格被称为 RESTful 。



## REST

### 资源（Resource）

所谓 “资源”，就像网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本，一张图片，一首歌曲，一种服务，总之就是一个具体的实例。你可以使用一个URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的URI 就可以了，因此 URI 就成了每一个资源的地址或独一无二的识别符。所谓 “上网” 就是与互联网上一系列的 “资源” 互动，调用它们的 URI。



### 表现层（Representation）

“资源” 是一种信息实体，它可以有多种外在表现形式，把 “资源”具体呈现出来的形式，叫做它的 “表现层”。

URI 只代表资源的实体，代表它的形式。严格地说，有些网站最后的 “.html” 后缀名是不必要的，因为这个后缀表示格式，属于“表现层” 范畴，而 URI 应该只代表 “资源” 的位置。它的具体表现形式，应该在 HTTP 请求头的信息中使用 Accept 和 Content-Type 字段指定。



### 状态转换（State Transfer）

访问一个网站，就代表客户端和服务端的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。

互联网通信协议 HTTP 协议，是一个无状态协议。这意味着，所有的状态都保存在服务端。因此，如果客户端想要操作服务器，就必须通过某种手段，让服务器端发生“状态转换（State Transfer）”。而这种转换是建立在表现层之上的，所以就是 “表现层状态转化” 。

客户端用到的手段，只能是 HTTP 协议。具体来说，就是 HTTP 协议中，四个表示操作方式的动词：GET、POST、PUT、DELETE 。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建或更新资源，PUT 用来更新资源，DELETE 用来删除资源





## 规范

路径又称 “终点”（endpoint），表示 API 的具体网址。实际开发中常见的规范如下：

1. 网址中不能有动词，只能有名词，API 中的名词也应该使用复数。因为 REST 中的资源往往和数据库中的表对应，而数据库中的表都是同种记录的 “集合”。

   如果 API 调用并不涉及资源（如计算，翻译等操作）的话，可以用动词。比如：`GET /calculate?param1=11&param2=33` 。

2. 不用大写字母，建议用中杠 - 不用下杠 _ 。比如邀请码写成 `invitation-code` 而不是 `invitation_code` 。

3. 善用版本化 API。

   当我们的 API 发生了重大改变而不兼容前期版本的时候，我们可以通过 URL 来实现版本化，比如 `http://api.example.com/v1`、`http://apiv1.example.com` 。版本不必非要是数字，只是数字用的最多，日期、季节都可以作为版本标识符，项目团队达成共识就可。

4. 接口尽量使用名词，避免使用动词。

    RESTful API 操作（HTTP Method）的是资源（名词）而不是动作（动词）。





# FAQ🎃 

## keep-alive

HTTP 和 TCP 都有  keep-alive 参数，但是含义不同。

- HTTP 的 keep-alive：让一个 TCP 连接存活久一些，表示一个 HTTP 长连接

- TCP 的 keep-alive：检查当前 TCP 连接是否还在保持，当一个连接 “一段时间” 没有数据通讯时，一方会发出一个心跳包（Keep Alive），如果对方有回包则表明当前连接有效，继续监控。





## HTTP如何实现长连接？

HTTP 的长连接和短连接本质上是 TCP 长连接和短连接。

- 短连接：浏览器和服务器每进行一次 HTTP 操作，就建立一次连接，但任务结束就中断连接。

  用户数目较多的 Web 网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。

- 长连接：客户端和服务器之间 HTTP 请求会复用同一条 TCP 连接。

  多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏、数据库连接等。

  

在早期的 HTTP/1.0 中，浏览器每次发起 HTTP 请求都要与服务器创建一个新的 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。然而创建和关闭连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要复用连接。

在 HTTP/1.1 版本中默认使用长连接，通过在头部（请求和响应头）设置 `Connection: keep-alive` 。服务器在响应后保持该 TCP 连接打开，在同一个客户机与服务器之间的后续请求和响应报文可通过相同的连接进行传送，不需要重新进行 TCP 连接和释放。

<img src="http://store.secretcamp.cn/uPic/image-20210301211142613202103012111421614604302grDEoIgrDEoI.png" alt="image-20210301211142613" style="zoom: 50%;" />



## TCP长连接什么时候会超时？

长时间的保持 TCP 连接时容易导致系统资源被无效占用，如果没有数据要发送，应该关闭连接。

TCP 的 keep-alive 包含三个参数，支持在系统内核的 net.ipv4 里面设置。

当 TCP 链接之后，闲置了 tcp_keepalive_time，则会发生心跳检测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了 tcp_keepalive_probes 次，就会丢弃该链接。

```
tcp_keepalive_intvl = 15
tcp_keepalive_probes = 5
tcp_keepalive_time = 1800
```







## GET与POST的区别

本质上无区别，都是 HTTP 协议中的请求方法，所谓区别都是浏览器厂家根据约定做的限制。

在浏览器中的区别：

- GET 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 *POST* 参数放在请求主体中，并且参数不会被保留，相比 GET 方法，POST方法更安全，主要用于修改服务器上的资源。

- GET 请求只支持 URL 编码，POST 请求支持多种编码格式。

- GET 只支持 ASCII 字符格式的参数，而 POST 方法没有限制。

- GET 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 POST 方法提交的数据没限制。

- GET 方法产生一个 TCP 数据包，POST 方法可能产生两个。







## HTTP请求的全过程

发起请求之前：

1. DHCP 配置主机 IP
2. NAT 将私有 IP 转为公有 IP



发起请求：

2. DNS解析
   - 浏览器缓存 -> 系统缓存 -> 路由器缓存 -> 网络供应商缓存 -> 递归搜索DNS服务器
3. 客户端与服务端建立连接
   - 客户端与负载均衡设备（应用层）先建立连接，然后获取对应服务器的 IP 地址
   - 获取到服务端的 IP 地址后，发起 TCP 三次握手
   - ARP 解析服务端的 MAC 地址
4. 建立 TCP 连接后发起 HTTP 请求
5. 服务器响应 HTTP 请求
   - 后台处理阶段
   - 业务逻辑处理完后，由表现层发出 HTTP 响应
6. 浏览器解析 HTML 代码，并请求 HTML 代码中的资源
   - CDN：如果请求的数据是静态文件且在 CDN 上，那么 CDN 服务器又会处理这个用户的请求
7. 浏览器对页面进行渲染呈现给用户
8. 断开 TCP 连接（长连接则不会立即断开）







## Cookie与Session的区别

基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中，后者不仅将会话状态信息存储在浏览器 Cookie 中，服务器端也保存了状态信息。





## Cookie被禁用了怎么办？

1. 可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。

2. 将 Cookie 写在表单（Form）的隐藏域中，在表单提交时将 Cookie 一起提交上去

